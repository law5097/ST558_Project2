---
title: "ST558 Project 2"
subtitle: "Lee Worthington"
format: 
  html:
    embed-resources: true
editor: visual
editor_options: 
  chunk_output_type: inline
---

# 7-8-2024 this code is not totally inline with my app code now due to a bunch of changes I made, however the gist is the same minus the app functionality and flexibility

## Setup environment

```{r}
#| warning: FALSE
#| message: FALSE

library(readr)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(tools)
library(httr)
library(jsonlite)
library(magrittr)
library(purrr)


# API list
  # https://github.com/public-apis/public-apis?tab=readme-ov-file#business
# good ones?
  # https://fiscaldata.treasury.gov/api-documentation/
  # this is "fed treasury" in the api list
# using this data @@@@@@@@@
  # https://fiscaldata.treasury.gov/datasets/revenue-collections-management/u-s-government-revenue-collections

```

## 1 API query function (see hw4 for example)

```{r}
#| warning: FALSE
#| message: FALSE

# Define API function
get_revenue_collections_data <- function(
    record_date = NULL, 
    electronic_category_desc = NULL, 
    channel_type_desc = NULL, 
    tax_category_desc = NULL, 
    record_fiscal_year = NULL, 
    record_calendar_year = NULL, 
    record_calendar_month = NULL, 
    format = "json", 
    page_number = 1, 
    page_size = 1000){
  
  # Set base URL and endpoint
  base_url <- 'https://api.fiscaldata.treasury.gov/services/api/fiscal_service/'
  end_point <- 'v2/revenue/rcm'
  full_url <- paste0(base_url, end_point)
  
  # baseR URL encoding function - this puts the text in a url friendly format, such as removing spaces
  url_encode <- function(value) {
    return(URLencode(as.character(value), reserved = TRUE))
  }
  
  # Function to put the filters in a string format the API expects
  build_filter <- function(field, value, operator = "eq") {
    
    # Check if there's any value 
    if (!is.null(value) && length(value) > 0) {
      
      # If there's more than a single value passed, wrap it in IN
      if (length(value) > 1) {
        return(paste0(field, ":in:(", paste(url_encode(value), collapse = ","), ")"))
      } 
      # Otherwise just paste the single value that was passed with the default operator, eq
      else {
        return(paste0(field, ":", operator, ":", url_encode(value)))
      }
    }
    
    # Return nada if there's no value
    return(NULL)
  }
  
  # Function to put the RANGE filters in a string format the API expects
  build_range_filter <- function(field, values) {
    if (!is.null(values) && length(values) == 2) {
      gte_value <- values[1]
      lte_value <- values[2]
      if (field == "record_calendar_month") {
        gte_value <- sprintf("%02d", as.numeric(gte_value))
        lte_value <- sprintf("%02d", as.numeric(lte_value))
      }
      return(c(
        paste0(field, ":gte:", url_encode(gte_value)),
        paste0(field, ":lte:", url_encode(lte_value))
      ))
    }
    return(NULL)
  }
  
  # Take the given inputs and put them in the necessary format, using my functions above
  filters <- c(
    build_range_filter("record_calendar_year", record_calendar_year),
    build_range_filter("record_calendar_month", record_calendar_month),
    build_filter("electronic_category_desc", electronic_category_desc),
    build_filter("tax_category_desc", tax_category_desc),
    build_filter("channel_type_desc", channel_type_desc)
  )
  
  # Flatten the list of filters
  filters <- unlist(filters)
  
  # Remove NULL values from filters
  filters <- filters[!sapply(filters, is.null)]
  
  # Combine the filters into a single string separated by commas
  filter_string <- if (length(filters) > 0) {
    paste(filters, collapse = ",")
  } else {
    ""
  }
  
  # Construct the full URL with query parameters
  query_string <- paste0("filter=", filter_string, "&format=", format, "&page[number]=", page_number, "&page[size]=", page_size)
  full_query_url <- paste0(full_url, "?", query_string)
  
  # Print for debugging @@@@@@@@@@@@@@@@@@@@@
  # print(full_query_url)
  
  # Get the data from the API
  url_data <- httr::GET(full_query_url)
  
  # Response check
  if (status_code(url_data) != 200) {
    stop("Failed to retrieve data: ", status_code(url_data), " - ", content(url_data, "text"))
  }
  
  # Parse data as tibble
  data <- url_data |>
    httr::content(as = "text") |>
    fromJSON(flatten = TRUE, simplifyDataFrame = TRUE) |>
    pluck("data") |>
    as_tibble()
  
  # Print for debugging @@@@@@@@@@@@@@@@@@@@@
  # print(head(data))
  
  # Return the results
  return(data)
}

# Testing
revenue_data <- get_revenue_collections_data(
  record_date = NULL,
  electronic_category_desc = 'Electronic Settlement',
  channel_type_desc = 'Mail',
  tax_category_desc = NULL,
  record_fiscal_year = NULL,
  record_calendar_year = NULL,
  record_calendar_month = NULL,
  page_number = 1, 
  page_size = 10000
)
dim(revenue_data)
min(revenue_data$record_date)
max(revenue_data$record_date)

```

## 2 Data summary functions

### Contingency table

```{r}
#| warning: FALSE
#| message: FALSE

# contingency table
contingency_table <- revenue_data |>
  group_by(record_calendar_year) |>
  drop_na(record_calendar_year) |>
  summarize(count = n())

# show results
contingency_table 

```

### Summary statistics

```{r}
#| warning: FALSE
#| message: FALSE

# get summary stats
numerical_summaries <- revenue_data |>
  
  # convert values to numeric
  mutate(net_collections_amt = as.numeric(net_collections_amt)) |>
  
  # group by given field
  group_by(tax_category_desc) |>
  
  # generate summary statistics
  summarize(
    value_total = sum(net_collections_amt, na.rm = TRUE),
    value_avg = mean(net_collections_amt, na.rm = TRUE),
    value_min = min(net_collections_amt, na.rm = TRUE),
    value_25th = quantile(net_collections_amt, 0.25, na.rm = TRUE),
    value_50th = median(net_collections_amt, na.rm = TRUE),
    value_75th = quantile(net_collections_amt, 0.75, na.rm = TRUE),
    value_100th = max(net_collections_amt, na.rm = TRUE)
  )

# show results
print(numerical_summaries) 

```

### 4 plots

```{r}
#| warning: FALSE
#| message: FALSE

# load library to format dollars
library(scales)

# Convert to numeric for plots
revenue_data <- revenue_data |>
  mutate(
    net_collections_amt = as.numeric(net_collections_amt),
    record_calendar_year = as.integer(record_calendar_year),
    record_calendar_month = as.integer(record_calendar_month)
  )

# Extract date range and format as "Month YYYY"
date_range_year <- range(revenue_data$record_calendar_year, na.rm = TRUE)
date_range_month <- range(revenue_data$record_calendar_month, na.rm = TRUE)
min_date <- paste(month.name[date_range_month[1]], date_range_year[1])
max_date <- paste(month.name[date_range_month[2]], date_range_year[2])
date_range_text <- paste(min_date, "to", max_date)

# Histogram
ggplot(revenue_data, aes(x = net_collections_amt)) +
  geom_histogram(bins = 25, fill = "lightgreen", color = "black", alpha = 0.5) +
  labs(title = paste("Histogram of Net Collections Amount between", date_range_text), x = "Net Collections Amount", y = "Count") +
  scale_x_log10(labels = dollar) +
  theme_minimal()

# Boxplot
ggplot(revenue_data, aes(x = tax_category_desc, y = net_collections_amt)) +
  geom_boxplot(fill = "lightgreen", color = "black", alpha = 0.5) +
  labs(title = paste("Distribution of Net Collections by Tax Category between", date_range_text), x = "Tax Category", y = "Net Collections Amount") +
  scale_y_log10(labels = dollar) +
  theme_minimal()

# Line plot by month
ggplot(revenue_data, aes(x = as.factor(record_calendar_month), y = net_collections_amt, color = tax_category_desc, group = tax_category_desc)) +
  stat_summary(fun = sum, geom = "line") +
  labs(title = paste("Net Collections by Month and Tax Category between", date_range_text), x = "Month", y = "Net Collections Amount") +
  scale_y_continuous(labels = dollar) +
  theme_minimal()

# Summarize data for heatmap
heatmap_data <- revenue_data %>%
  group_by(tax_category_desc, channel_type_desc) %>%
  summarize(total_net_collections = sum(net_collections_amt, na.rm = TRUE), .groups = "drop")

# Heatmap
ggplot(heatmap_data, aes(x = tax_category_desc, y = channel_type_desc, fill = total_net_collections)) +
  geom_tile(alpha = 0.5) +
  geom_text(aes(label = scales::dollar(total_net_collections)), color = "black", size = 3) +
  labs(title = paste("Heatmap of Tax Category by Channel Type between", date_range_text), x = "Tax Category", y = "Channel Type", fill = "Total Net Collections") +
  scale_fill_gradient(low = "lightgreen", high = "darkgreen", labels = dollar) +
  theme_minimal()

```

```{r}

```
